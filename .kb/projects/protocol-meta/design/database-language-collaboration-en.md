# Database-Language Agent Collaboration Rules

## Overview
This document defines efficient and systematic collaboration protocols between database experts and language-specific experts.

## Core Collaboration Principles

### üéØ Role Separation and Responsibilities
- **Language Agents**: Application logic, data structure definition, ORM/ODM setup
- **DB Agents**: Schema design, query optimization, indexing, performance tuning
- **Data Source Agents**: Spreadsheet parsing, data transformation, quality validation
- **Complete Separation**: Each agent focuses only on their specialized domain

### üîÑ Claude Mediation Model
All collaboration between expert agents is conducted through **Claude (L2) mediation**.

```
Planner Spreadsheet
        ‚Üì
SpreadsheetExpert ‚Üî Claude ‚Üî Language Agent
        ‚Üì              ‚Üì              ‚Üì
    Data Transform   Work Coordination   Code Generation
        ‚Üì                            ‚Üì
    DB Agent ‚Üê ‚Üê ‚Üê ‚Üê ‚Üê ‚Üê ‚Üê ‚Üê ‚Üê ‚Üê Final Result
        ‚Üì
    DB Design/Optimization
```

## Collaboration Workflows

### üìä Spreadsheet-Based Data Development Scenario

#### Situation: Building Game Item System
```
Planner: "I've added new items and adjusted balance"
```

#### Workflow Steps
```
1. SpreadsheetExpert ‚Üí Claude: "Items.xlsx file has been updated"
2. Claude ‚Üí UnityExpert: "Please convert item data to ScriptableObject"
3. Claude ‚Üí SQLiteExpert: "Please update game DB schema to match item data"
4. Claude: Integrate both results and verify consistency
```

### üèóÔ∏è New Feature Development Scenario

#### Step 1: Requirements Analysis (Gemini ‚Üí Claude)
```
Gemini: "Implement user management API with FastAPI + PostgreSQL"
Claude: Break down work by language + DB
```

#### Step 2: Data Model Definition (Language ‚Üí Claude ‚Üí DB)
```
1. Claude ‚Üí PythonExpert: "Define required fields for User model with Pydantic"
2. PythonExpert ‚Üí Claude: Return SQLAlchemy model and API schema
3. Claude ‚Üí PostgreSQLExpert: "Design optimized tables and indexes matching Python model"
4. PostgreSQLExpert ‚Üí Claude: Return DDL scripts and index strategy
```

#### Step 3: Integration and Verification (Claude)
```
Claude performs:
- Integrate Python code and PostgreSQL DDL
- Generate data migration scripts (Alembic)
- Verify API endpoint and DB query connection points
```

### üîß Existing System Optimization Scenario

#### Performance Problem Resolution
```
1. Problem Identification: "User search API is slow"
2. Claude ‚Üí PostgreSQLExpert: "Analyze and optimize users table query performance"
3. Claude ‚Üí PythonExpert: "Modify FastAPI code according to PostgreSQL recommendations"
4. Claude: Integrate changes and test
```

## Language-Specific DB Integration Patterns

### üêç Python Ecosystem

#### Python ‚Üî PostgreSQL
```python
# Code generated by PythonExpert
from sqlalchemy import Column, Integer, String, DateTime
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

class User(Base):
    __tablename__ = 'users'
    
    id = Column(Integer, primary_key=True)
    email = Column(String(255), unique=True, nullable=False)
    username = Column(String(50), unique=True, nullable=False)
    created_at = Column(DateTime, default=func.now())
```

```sql
-- DDL generated by PostgreSQLExpert
CREATE TABLE users (
    id BIGSERIAL PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    username VARCHAR(50) UNIQUE NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_username ON users(username);
```

#### Python ‚Üî MongoDB
```python
# PythonExpert: Pydantic model
from pydantic import BaseModel, Field
from datetime import datetime

class User(BaseModel):
    email: str = Field(..., description="User email")
    username: str = Field(..., description="Unique username")
    created_at: datetime = Field(default_factory=datetime.utcnow)
```

```javascript
// MongoDBExpert: Collection schema and indexes
db.users.createIndex({ "email": 1 }, { unique: true });
db.users.createIndex({ "username": 1 }, { unique: true });
db.users.createIndex({ "created_at": -1 });
```

### üéÆ Unity Ecosystem

#### Unity C# ‚Üî SQLite
```csharp
// Code generated by UnityExpert
[System.Serializable]
public class PlayerData
{
    public int playerId;
    public string playerName;
    public int level;
    public float experience;
    public string settingsJson;
}

public class PlayerDataManager : MonoBehaviour
{
    private GameDatabase database;
    
    public void SavePlayer(PlayerData data)
    {
        database.SavePlayerData(data);
    }
}
```

```sql
-- Schema generated by SQLiteExpert
CREATE TABLE players (
    player_id INTEGER PRIMARY KEY AUTOINCREMENT,
    player_name TEXT NOT NULL,
    level INTEGER DEFAULT 1,
    experience REAL DEFAULT 0.0,
    settings_json TEXT DEFAULT '{}',
    created_at INTEGER DEFAULT (strftime('%s', 'now'))
);

CREATE INDEX idx_players_name ON players(player_name);
```

### üü¢ Node.js Ecosystem

#### Node.js ‚Üî Redis
```javascript
// Code generated by NodeJSExpert
class UserCacheService {
    constructor(redisClient) {
        this.redis = redisClient;
    }
    
    async cacheUser(userId, userData) {
        const key = `user:${userId}`;
        await this.redis.setex(key, 3600, JSON.stringify(userData));
    }
    
    async getUser(userId) {
        const key = `user:${userId}`;
        const cached = await this.redis.get(key);
        return cached ? JSON.parse(cached) : null;
    }
}
```

```redis
# Optimization provided by RedisExpert
# User cache pattern
SET user:1001 '{"name":"John","email":"john@example.com"}' EX 3600

# Session management
SET session:abc123 "user_id:1001;role:admin" EX 7200

# Real-time counter
INCR page_views:20240814
EXPIRE page_views:20240814 86400
```

## Database-Specific Collaboration

### üóÑÔ∏è Relational Databases (MySQL, PostgreSQL)

#### Common Collaboration Patterns
1. **Schema-First Design**
   - DB Expert: ERD design ‚Üí DDL generation
   - Language Expert: ORM model mapping
   
2. **Migration Management**
   - DB Expert: ALTER TABLE scripts
   - Language Expert: Migration tool setup (Alembic, Sequelize, etc.)

3. **Query Optimization**
   - DB Expert: Execution plan analysis, index recommendations
   - Language Expert: ORM query optimization

### ‚ö° Cache Databases (Redis)

#### Collaboration Patterns
1. **Cache Strategy Development**
   - Language Expert: Identify data requiring cache
   - Redis Expert: Provide cache patterns and TTL strategy

2. **Data Structure Selection**
   - Language Expert: Define application requirements
   - Redis Expert: Select optimal Redis data types

### üçÉ NoSQL Databases (MongoDB)

#### Collaboration Patterns
1. **Schemaless Design**
   - Language Expert: Define document structure
   - MongoDB Expert: Decide embedding vs reference strategy

2. **Aggregation Pipeline**
   - Language Expert: Business logic requirements
   - MongoDB Expert: Write efficient aggregation queries

## Conflict Resolution and Priorities

### üö® Conflict Resolution Principles

#### 1. Technical Conflicts
```
Example: Index design disagreement
- DB Expert: "Recommend composite index (status, created_at)"
- Language Expert: "Individual indexes are more flexible in ORM"

Resolution: Claude decides based on performance test results
```

#### 2. Priority Setting
1. **Data Consistency** > Development Convenience
2. **Performance** > Code Simplicity  
3. **Security** > Implementation Speed
4. **Scalability** > Initial Implementation Complexity

### üîß Collaboration Optimization Guidelines

#### Do's (Recommendations)
- ‚úÖ Define clear interfaces (API ‚Üî DB)
- ‚úÖ Schema evolution through version control
- ‚úÖ Document each expert's recommendations
- ‚úÖ Share performance test results

#### Don'ts (Avoid)
- ‚ùå Language agents directly modifying DB schema
- ‚ùå DB agents interfering with application logic
- ‚ùå Direct communication between agents (bypassing Claude)
- ‚ùå Unilateral technical decisions

## Quality Assurance Checklist

### üîç Pre-Completion Verification

#### Technical Verification
- [ ] Language-specific coding standards compliance
- [ ] DB-specific optimization techniques applied
- [ ] Index strategy appropriateness
- [ ] Transaction scope review
- [ ] Security vulnerability check

#### Integration Verification  
- [ ] API-DB interface consistency
- [ ] Unified error handling strategy
- [ ] Logging and monitoring setup
- [ ] Backup and recovery plan
- [ ] Performance benchmark passed

## Success Case Templates

### üìã User Authentication System Development

#### Participating Agents
- **NodeJSExpert**: Express.js-based authentication API
- **RedisExpert**: Session management and Rate Limiting  
- **PostgreSQLExpert**: User information storage

#### Collaboration Deliverables
1. **Node.js Code**: JWT token management, bcrypt encryption
2. **Redis Configuration**: Session storage, login attempt limiting
3. **PostgreSQL Schema**: User tables, index optimization
4. **Integration Documentation**: API specification, security policies, operational guides

---

**Through these collaboration rules, we maximize each expert's expertise while ensuring system-wide consistency and quality.**